#!/usr/bin/env perl
use strict;
use feature 'unicode_strings';
use warnings FATAL => "utf8";

# Non-core modules
use MIME::Parser;

# Core modules
use Encode qw(decode);
use File::Temp qw(tempdir tempfile);

=head1 NAME

barkmerge.pl - Merge new sections of a specific style into an existing
Bark message and output the updated message.

=head1 SYNOPSIS

  barkmerge.pl -style exstyl -msg ex.msg < input.parts

=head1 DESCRIPTION

A Bark-format MIME message is read from the file given by the C<-msg>
option.  It is then modified such that any section that has a style
matching that given by the C<-style> option is instead replaced by a
part read from a stream of parts coming in over standard input.  (Use a
style name of a single hyphen to select the default style.)  The result
the overwrites the original message file.

The input stream of parts is in the same format generated by the
C<barkecho.pl> script when a specific style is selected.  The sections
from that input stream are used to replace sections of a matching style
in the given source message in the same order that they are given.  It
is an error if there are not exactly the right number of replacement
sections in the input stream.

By default, text sections are encoded with quoted-printable.  If you
want to use base-64 encoding instead, include the C<-base64> option.

=cut

# ===================
# Temporary directory
# ===================

# Create a temporary directory that will be used by the MIME parser for
# parsing messages, and indicate that the temporary directory and all
# files contained within should be deleted when the script ends
#
my $mime_dir = tempdir(CLEANUP => 1);

# ==========
# Part files
# ==========

# Each part that will be included in the MIME message has its own
# temporary file here.  There is an END block that unlinks all the
# temporary files when the script ends.
#
# The @ppaths array stores the paths to each temporary file part, in the
# order they appear in the message.
#
my @ppaths;
END {
  unlink(@ppaths);
}

# ==========
# Local data
# ==========

# The MIME entity for the message we are building.
#
my $eout = MIME::Entity->build( Type    => "multipart/mixed",
                                From    => 'author@example.com',
                                To      => 'publisher@example.com',
                                Subject => "bark");

# ==================
# Program entrypoint
# ==================

# First off, set standard input to use UTF-8
#
binmode(STDIN, ":encoding(utf8)") or
  die "Failed to change standard output to UTF-8, stopped";

# Define variables for options
#
my $has_style = 0;
my $has_src   = 0;

my $style_sel;
my $src_path;
my $enc_mode = 'quoted-printable';

# Parse parameters
#
for(my $i = 0; $i <= $#ARGV; $i++) {
  if ($ARGV[$i] eq '-style') {
    ($i < $#ARGV) or die "-style option requires parameter, stopped";
    $i++;
    
    $has_style = 1;
    $style_sel = $ARGV[$i];
    
    (($style_sel eq '-') or
        ($style_sel =~ /^[A-Za-z0-9_]+$/u)) or
      die "Invalid style name, stopped";
  
  } elsif ($ARGV[$i] eq '-msg') {
    ($i < $#ARGV) or die "-msg option requires parameter, stopped";
    $i++;
    
    $has_src = 1;
    $src_path = $ARGV[$i];
    
    (-f $src_path) or die "Can't find source file '$src_path', stopped";
    
  } elsif ($ARGV[$i] eq '-base64') {
    $enc_mode = "base64";
  
  } else {
    die "Unrecognized option '$ARGV[$i]', stopped";
  }
}

# Make sure we got both a style and a source path
#
($has_style) or die "Missing -style option, stopped";
($has_src) or die "Missing -msg option, stopped";

# Parse the MIME message from the source file
#
my $parser = MIME::Parser->new;
$parser->output_under($mime_dir);

my $ent = $parser->parse_open($src_path);

# Make sure MIME message is type multipart/mixed
#
($ent->mime_type eq 'multipart/mixed') or
  die "MIME message in wrong format, stopped";

# Make sure MIME message has at least one part
#
($ent->parts > 0) or die "MIME message is empty, stopped";

# Read the first line of standard input and verify it is the proper
# format for a separator line after dropping trailing whitespace and
# line breaks
#
my $sep_line = <STDIN>;
(defined $sep_line) or die "Failed to read separator line, stopped";

$sep_line =~ s/[ \t\r\n]+$//u;
($sep_line =~ /<\?bark_[A-Za-z0-9]*\?>/u) or
  die "Separator line is not valid format, stopped";

# Process each part of the message
#
my $last_footer;
for(my $i = 0; $i < $ent->parts; $i++) {
  
  # Get the current part
  my $p = $ent->parts($i);
  
  # Make sure part is a plain-text format
  (($p->mime_type =~ /^text\/plain$/ui) or
      ($p->mime_type =~ /^text\/plain;/ui)) or
    die "Wrong MIME part type, stopped";
  
  # Open the current part for reading, in binary mode so we can manually
  # decode to UTF-8
  $p = $p->bodyhandle;
  $p->binmode(1);
  my $io = $p->open("r");
  
  # Read the initial footer line from the part and trim trailing LF or
  # CR+LF
  my $footer;
  ($footer = $io->getline) or
    die "Failed to read MIME initial footer, stopped";
  $footer = decode("UTF-8", $footer);
  $footer =~ s/[\r\n]*$//ug;
  
  # If this is not the first part, make sure footer is same as in last
  # part; else, store the first part's footer in last_footer
  if ($i > 0) {
    ($last_footer eq $footer) or
      die "Footer changes between parts, stopped";
  } else {
    $last_footer = $footer;
  }
  
  # Read the header line from the part
  my $first_line;
  ($first_line = $io->getline) or
    die "Failed to read MIME part header line, stopped";
  $first_line = decode("UTF-8", $first_line);
  
  # Decode the header line
  ($first_line =~ /^(\+|:)([A-Za-z0-9_\-]+)[ \t\r\n]*$/u) or
    die "MIME part header line in invalid format, stopped";
  my $join_mode = $1;
  my $style_name = $2;
  
  # Check style name
  (($style_name eq '-') or (not ($style_name =~ /\-/u))) or
    die "MIME part header has invalid style, stopped";
  
  # Different handling depending on whether the section style matches
  # the selected style name
  if ($style_name eq $style_sel) {
    # Section has a replacement style, so create a temporary file and
    # merge lines from the replacement file in
    my $tpath;
    my $th;
    
    ($th, $tpath) = tempfile();
    push @ppaths, ($tpath);
    
    binmode($th, ":encoding(utf8)") or
      die "Failed to change temporary file to UTF-8, stopped";
    
    # Print the initial footer and the header line to the temporary file
    print {$th} "$footer\n$join_mode$style_name\n";
    
    # Read an echo all replacement lines to the temporary file, making
    # sure they don't match the footer line, until we hit the separator
    # line
    my $found_sep = 0;
    while (<STDIN>) {
      
      # Strip line break
      s/[\r\n]*$//ug;
      
      # If this is the separator line, we are done with the loop
      if ($_ eq $sep_line) {
        $found_sep = 1;
        last;
      }
      
      # If we got here, make sure line doesn't match footer line
      ($_ ne $footer) or die "Footer collision, stopped";
      
      # Print the line to the temporary file
      print {$th} "$_\n";
    }
    if (not $found_sep) {
      die "Not enough replacement parts, stopped";
    }
    
    # Write the footer line to the temporary file and close it
    print {$th} "$footer\n";
    close($th);
    
  } else {
    # Section has a non-replacement style, so create a temporary file
    # and dump the current section data to it
    my $tpath;
    my $th;
    
    ($th, $tpath) = tempfile();
    push @ppaths, ($tpath);
    
    binmode($th, ":encoding(utf8)") or
      die "Failed to change temporary file to UTF-8, stopped";
    
    # Print the initial footer and the header line to the temporary file
    print {$th} "$footer\n$join_mode$style_name\n";
    
    # Read and echo all data lines to the temporary file until we hit
    # the footer line
    my $found_footer = 0;
    while (my $dl = $io->getline) {
      
      # Decode the current line to UTF-8
      $dl = decode("UTF-8", $dl);
      
      # Strip line break
      $dl =~ s/[\r\n]*$//ug;
      
      # If this is the footer line, we are done with the loop
      if ($dl eq $footer) {
        $found_footer = 1;
        last;
      }
      
      # Print the line with a line break to the temporary file
      print {$th} "$dl\n";
    }
    if (not $found_footer) {
      die "MIME part missing footer, stopped";
    }
    
    # We've hit the footer line, so read the rest of the data in the MIME
    # part, making sure each line is blank or empty
    while (my $bl = $io->getline) {
      $bl = decode("UTF-8", $bl);
      ($bl =~ /^[ \t\r\n]*$/u) or
        die "MIME part contains data after footer, stopped";
    }
    
    # Write the footer line to the temporary file and close it
    print {$th} "$footer\n";
    close($th);
  }
  
  # Close the MIME part reader handle
  close($io);
}

# Make sure nothing remains in standard input except blank lines
#
while (<STDIN>) {
  (/^[ \t\r\n]*$/u) or die "Too many replacement parts, stopped";
}

# Purge disk files of the MIME parser since we now have everything in
# temporary files
#
$ent->purge;

# Attach all text parts to the message
#
for my $p (@ppaths) {
  $eout->attach(Path     => $p,
                Type     => "text/plain;charset=UTF-8",
                Encoding => $enc_mode);
}

# Write the whole message to the source path, overwriting what's there
#
open(my $fh, "> :encoding(utf8)", $src_path) or
  die "Can't open message file, stopped";
$eout->print($fh);
close($fh);

=head1 AUTHOR

Noah Johnson, C<noah.johnson@loupmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2021 Multimedia Data Technology Inc.

MIT License:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
